use std::path::Path;

use anyhow::{anyhow, Result};
use byteorder::{BigEndian, ReadBytesExt};
use exif::Exif;

use crate::codec::{Image, ImageCodec};
use libheif_rs::{HeifContext, ItemId};

pub struct HEIC;

impl ImageCodec for HEIC {
    fn decode(path: &Path) -> Result<Image> {
        let path = match path.to_str() {
            Some(p) => p,
            _ => return Err(anyhow!("invalid path string")),
        };

        let ctx = match HeifContext::read_from_file(path) {
            Ok(ctx) => ctx,
            Err(e) => return Err(anyhow!(e)),
        };

        let handle = match ctx.primary_image_handle() {
            Ok(handle) => handle,
            Err(e) => return Err(anyhow!(e)),
        };

        let metas = vec!["Exif", "IPTC", "iptc", "Iptc", "TIFF", "Tiff", "XMP"];
        for meta in metas {
            let meta_count = handle.number_of_metadata_blocks(meta);
            println!("{}: {}", meta, meta_count);
        }


        // get exif
        let mut meta_ids: Vec<ItemId> = vec![0; 1];
        let count = handle.metadata_block_ids("Exif", &mut meta_ids);
        let exif_data = handle.metadata(meta_ids[0])?;

        let exif = parse_exif(exif_data);

        Ok(Image {})
    }

    fn encode(image: &Image) -> anyhow::Result<()> {
        todo!()
    }
}

fn parse_exif(raw: Vec<u8>) -> Result<Exif> {
    // read first 4-bytes indicating the offset of the TIFF header for EXIF
    let mut first_four = &raw[0..4];
    let offset = match first_four.read_u32::<BigEndian>() {
        Ok(offset) => offset + 4,
        Err(e) => return Err(anyhow!(e)),
    };

    let data = Vec::from(&raw[offset as usize..]);

    // parse exif
    let exif_reader = exif::Reader::new();
    match exif_reader.read_raw(data) {
        Ok(exif) => Ok(exif),
        Err(e) => Err(anyhow!(e)),
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn parse_exif_from_bytes() {
        let data: Vec<u8> = vec![0, 0, 0, 6, 69, 120, 105, 102, 0, 0, 77, 77, 0, 42, 0, 0, 0, 8, 0, 11, 1, 15, 0, 2, 0, 0, 0, 11, 0, 0, 0, 146, 1, 16, 0, 2, 0, 0, 0, 9, 0, 0, 0, 158, 1, 18, 0, 3, 0, 0, 0, 1, 0, 1, 0, 0, 1, 26, 0, 5, 0, 0, 0, 1, 0, 0, 0, 168, 1, 27, 0, 5, 0, 0, 0, 1, 0, 0, 0, 176, 1, 40, 0, 3, 0, 0, 0, 1, 0, 2, 0, 0, 1, 49, 0, 2, 0, 0, 0, 21, 0, 0, 0, 184, 1, 50, 0, 2, 0, 0, 0, 20, 0, 0, 0, 206, 1, 66, 0, 4, 0, 0, 0, 1, 0, 0, 4, 0, 1, 67, 0, 4, 0, 0, 0, 1, 0, 0, 4, 0, 135, 105, 0, 4, 0, 0, 0, 1, 0, 0, 0, 226, 0, 0, 0, 0, 72, 97, 115, 115, 101, 108, 98, 108, 97, 100, 0, 0, 88, 50, 68, 32, 49, 48, 48, 67, 0, 0, 0, 0, 0, 72, 0, 0, 0, 1, 0, 0, 0, 72, 0, 0, 0, 1, 80, 105, 120, 101, 108, 109, 97, 116, 111, 114, 32, 80, 114, 111, 32, 51, 46, 50, 46, 51, 0, 0, 50, 48, 50, 51, 58, 48, 50, 58, 48, 49, 32, 49, 53, 58, 49, 52, 58, 50, 49, 0, 0, 18, 130, 154, 0, 5, 0, 0, 0, 1, 0, 0, 1, 192, 130, 157, 0, 5, 0, 0, 0, 1, 0, 0, 1, 200, 136, 34, 0, 3, 0, 0, 0, 1, 0, 3, 0, 0, 136, 39, 0, 3, 0, 0, 0, 1, 0, 64, 0, 0, 144, 0, 0, 7, 0, 0, 0, 4, 48, 50, 51, 48, 144, 3, 0, 2, 0, 0, 0, 20, 0, 0, 1, 208, 146, 4, 0, 10, 0, 0, 0, 1, 0, 0, 1, 228, 146, 5, 0, 5, 0, 0, 0, 1, 0, 0, 1, 236, 146, 7, 0, 3, 0, 0, 0, 1, 0, 2, 0, 0, 146, 9, 0, 3, 0, 0, 0, 1, 0, 0, 0, 0, 146, 10, 0, 5, 0, 0, 0, 1, 0, 0, 1, 244, 160, 1, 0, 3, 0, 0, 0, 1, 0, 1, 0, 0, 160, 2, 0, 4, 0, 0, 0, 1, 0, 0, 5, 199, 160, 3, 0, 4, 0, 0, 0, 1, 0, 0, 5, 199, 164, 5, 0, 3, 0, 0, 0, 1, 0, 35, 0, 0, 164, 32, 0, 2, 0, 0, 0, 33, 0, 0, 1, 252, 164, 51, 0, 2, 0, 0, 0, 11, 0, 0, 2, 30, 164, 52, 0, 2, 0, 0, 0, 8, 0, 0, 2, 42, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 68, 0, 0, 0, 8, 0, 0, 0, 1, 50, 48, 50, 51, 58, 48, 50, 58, 48, 49, 32, 49, 53, 58, 49, 52, 58, 50, 49, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 4, 0, 0, 0, 1, 0, 0, 0, 45, 0, 0, 0, 1, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 53, 56, 53, 52, 48, 49, 52, 48, 57, 49, 52, 56, 48, 48, 48, 48, 48, 49, 49, 52, 0, 0, 72, 97, 115, 115, 101, 108, 98, 108, 97, 100, 0, 0, 88, 67, 68, 32, 52, 53, 80, 0];
        let exif = parse_exif(data).unwrap();

        for f in exif.fields() {
            println!("{} {} {}",
                     f.tag, f.ifd_num, f.display_value().with_unit(&exif));
        }
    }

    // #[test]
    // fn parse_iptc_from_bytes() {
    //     let data: Vec<u8> = vec![0, 0, 0, 6, 69, 120, 105, 102, 0, 0, 77, 77, 0, 42, 0, 0, 0, 8, 0, 11, 1, 15, 0, 2, 0, 0, 0, 11, 0, 0, 0, 146, 1, 16, 0, 2, 0, 0, 0, 9, 0, 0, 0, 158, 1, 18, 0, 3, 0, 0, 0, 1, 0, 1, 0, 0, 1, 26, 0, 5, 0, 0, 0, 1, 0, 0, 0, 168, 1, 27, 0, 5, 0, 0, 0, 1, 0, 0, 0, 176, 1, 40, 0, 3, 0, 0, 0, 1, 0, 2, 0, 0, 1, 49, 0, 2, 0, 0, 0, 21, 0, 0, 0, 184, 1, 50, 0, 2, 0, 0, 0, 20, 0, 0, 0, 206, 1, 66, 0, 4, 0, 0, 0, 1, 0, 0, 4, 0, 1, 67, 0, 4, 0, 0, 0, 1, 0, 0, 4, 0, 135, 105, 0, 4, 0, 0, 0, 1, 0, 0, 0, 226, 0, 0, 0, 0, 72, 97, 115, 115, 101, 108, 98, 108, 97, 100, 0, 0, 88, 50, 68, 32, 49, 48, 48, 67, 0, 0, 0, 0, 0, 72, 0, 0, 0, 1, 0, 0, 0, 72, 0, 0, 0, 1, 80, 105, 120, 101, 108, 109, 97, 116, 111, 114, 32, 80, 114, 111, 32, 51, 46, 50, 46, 51, 0, 0, 50, 48, 50, 51, 58, 48, 50, 58, 48, 49, 32, 49, 53, 58, 49, 52, 58, 50, 49, 0, 0, 18, 130, 154, 0, 5, 0, 0, 0, 1, 0, 0, 1, 192, 130, 157, 0, 5, 0, 0, 0, 1, 0, 0, 1, 200, 136, 34, 0, 3, 0, 0, 0, 1, 0, 3, 0, 0, 136, 39, 0, 3, 0, 0, 0, 1, 0, 64, 0, 0, 144, 0, 0, 7, 0, 0, 0, 4, 48, 50, 51, 48, 144, 3, 0, 2, 0, 0, 0, 20, 0, 0, 1, 208, 146, 4, 0, 10, 0, 0, 0, 1, 0, 0, 1, 228, 146, 5, 0, 5, 0, 0, 0, 1, 0, 0, 1, 236, 146, 7, 0, 3, 0, 0, 0, 1, 0, 2, 0, 0, 146, 9, 0, 3, 0, 0, 0, 1, 0, 0, 0, 0, 146, 10, 0, 5, 0, 0, 0, 1, 0, 0, 1, 244, 160, 1, 0, 3, 0, 0, 0, 1, 0, 1, 0, 0, 160, 2, 0, 4, 0, 0, 0, 1, 0, 0, 5, 199, 160, 3, 0, 4, 0, 0, 0, 1, 0, 0, 5, 199, 164, 5, 0, 3, 0, 0, 0, 1, 0, 35, 0, 0, 164, 32, 0, 2, 0, 0, 0, 33, 0, 0, 1, 252, 164, 51, 0, 2, 0, 0, 0, 11, 0, 0, 2, 30, 164, 52, 0, 2, 0, 0, 0, 8, 0, 0, 2, 42, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 68, 0, 0, 0, 8, 0, 0, 0, 1, 50, 48, 50, 51, 58, 48, 50, 58, 48, 49, 32, 49, 53, 58, 49, 52, 58, 50, 49, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 4, 0, 0, 0, 1, 0, 0, 0, 45, 0, 0, 0, 1, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 53, 56, 53, 52, 48, 49, 52, 48, 57, 49, 52, 56, 48, 48, 48, 48, 48, 49, 49, 52, 0, 0, 72, 97, 115, 115, 101, 108, 98, 108, 97, 100, 0, 0, 88, 67, 68, 32, 52, 53, 80, 0];
    // }

    #[test]
    fn decode() {
        HEIC::decode(Path::new("sample.heic")).unwrap();
    }
}

